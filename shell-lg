#!/bin/bash

PROMPT_LINES=2

input_buffer=""

init_terminal() {
    tput reset

    # Hide cursor to avoid flickering
    tput civis

    # Save cursor position
    tput sc

    # Exclude prompt from scrollable area
    tput csr 0 "$(($(tput lines) - PROMPT_LINES - 1))"
}

restore_terminal() {
    tput reset
}

eval_javascript_in_gnome_shell_gdbus() {
    RET=$(gdbus call --session                       \
               --dest org.gnome.Shell                \
               --object-path /org/gnome/Shell        \
               --method org.gnome.Shell.Eval         \
	       "$1")
    if [[ "$RET" =~ ^\(false,.* ]]; then
        echo $RET > /dev/stderr
        return 1
    else
        echo "$RET" | sed -e 's/(true, ."\?\([^"]*\)"\?.)/\1/'
    fi
}

eval_javascript_in_gnome_shell() {
    json=$(mktemp)
    busctl call --user --json=short               \
                org.gnome.Shell                   \
                /org/gnome/Shell                  \
                org.gnome.Shell                   \
                Eval "s" "$1" > "$json"
    result=$(jq '.data[0]' < "$json")
    output=$(jq '.data[1] | select(. != null and . != "") | try fromjson catch .' < "$json")
    rm -f "$json"

    if [ "$result" = "false" ]; then
        echo -e "\e[31m${output:1:-1}\e[0m" > /dev/stderr
        return 1
    fi

    echo "$output"
    return 0
}

eval_javascript_in_looking_glass() {
    # encode the text so we can side-step complicated escaping rules
    ENCODED_TEXT=$(echo -n "$1" | xxd -p -c 9999999)

    eval_javascript_in_gnome_shell "
        const GLib = imports.gi.GLib;
        Main.createLookingGlass();
        const results = Main.lookingGlass._resultsArea;
        Main.lookingGlass._entry.text = '${ENCODED_TEXT}'.replace(/([0-9a-fA-F]{2})/g, (_, h) => String.fromCharCode(parseInt(h, 16)));
        Main.lookingGlass._entry.clutter_text.activate();
        GLib.timeout_add(GLib.PRIORITY_DEFAULT, 125, () => {
            const index = results.get_n_children() - 1;
            if (index < 0)
                return;
            const resultsActor = results.get_children()[index];
            const output = \`\${resultsActor.get_children()[1].get_children()[0].text}\${resultsActor.get_children()[1].get_children()[1].get_children()[0].text}\`;
            Main.lookingGlass._lastEncodedResult = output.split('').map(char => char.charCodeAt(0).toString(16).padStart(2, '0')).join('');
        });
    " > /dev/null

    if [ $? -ne 0 ]; then
        return
    fi

    sleep .250

    OUTPUT=$(eval_javascript_in_gnome_shell 'Main.lookingGlass._lastEncodedResult;' | xxd -r -p)

    if [ -z "$OUTPUT" ]; then
        echo -e "\e[31mCould not fetch result from call\e[0m" > /dev/stderr
        return
    fi

    eval_javascript_in_gnome_shell "delete Main.lookingGlass._lastEncodedResult;" > /dev/null

    if [ $MODE = tui ]; then
	echo ">>> $1"
    fi
    echo "${OUTPUT}"
}

draw_prompt_tui() {
    # Save cursor position
    tput sc

    # Move to the bottom of the terminal
    tput cup $(($(tput lines) - PROMPT_LINES)) 0

    # clear any crud off the prompt line
    tput el

    tput cnorm
    read -p ">>> " -re input_buffer
    STATUS="$?"
    tput civis

    [ $STATUS != 0 ] && exit

    if [ "$input_buffer" = "quit" -o "$input_buffer" = "q" -o "$input_buffer" = "exit" ]; then
        exit
    fi

    # Save input to history
    history -s "$input_buffer"

    # Move cursor back to saved position before output
    tput rc
}

draw_prompt_simple() {
    read -p ">>> " -re input
    if [ $? = 1 ]; then
        exit
    fi

    [ $? != 0 ] && continue

    if [ "$input" = "quit" -o "$input" = "q" -o "$input" = "exit" ]; then
        exit
    fi

    # Save input to history
    history -s "$input"
}

ask_user_for_input() {
    if [ $MODE = tui ]; then
	draw_prompt_tui
    else
	draw_prompt_simple
    fi
}

quit_message() {
    if [ $MODE = tui ]; then
	# Move to just below the prompt
	tput cup $(($(tput lines) - PROMPT_LINES + 1)) 0
    fi

    echo -ne "Type quit to exit"
    ask_user_for_input
}

load_history() {
    while IFS= read -r line; do
        history -s "$line"
    done < <(eval_javascript_in_gnome_shell 'Main.lookingGlass._history._history.join("\n");' | jq -r '. | select(. != null and . != "") | try fromjson catch .')
}

check_for_unsafe_mode() {
    unsafe_mode=$(eval_javascript_in_gnome_shell 'global.context.unsafe_mode')

    if [ "$unsafe_mode" != "true" ]; then
        echo -e "Please enable unsafe-mode in the Flags tab of looking glass." > /dev/stderr
        exit
    fi
}

eval_autocomplete_javascript() {
    TEXT="$1"
    OUTPUT=$(eval_javascript_in_gnome_shell_gdbus "
        const AsyncFunction = async function () {}.constructor;

        const command = \`
            const JsParse = await import('resource:///org/gnome/shell/misc/jsParse.js');
	    const commandHeader = \\\\\`
		const {Clutter, Gio, GLib, GObject, Meta, Shell, St} = imports.gi;
		const Main = await import('resource:///org/gnome/shell/ui/main.js');
		const inspect = Main.lookingGlass.inspect.bind(Main.lookingGlass);
		const it = Main.lookingGlass.getIt();
		const r = Main.lookingGlass.getResult.bind(Main.lookingGlass);
	    \\\\\`;

	    const completions = await JsParse.getCompletions('$TEXT', commandHeader, []);
	    return {
	        'completions': completions[0],
		'attrHead': completions[1]
	    };\`;
	AsyncFunction(command)();
    ")
    if [ $? = 1 ]; then
	echo fail
    fi
    echo "$OUTPUT" | sed -e "s/(true, '\(.*\)')$/\1/"
}


autocomplete() {
    RESULT="$(eval_autocomplete_javascript "$READLINE_LINE")"
    COMPLETIONS="$(echo "$RESULT" | jq '.completions[]' | sed 's/\"//g')"
    ATTR_HEAD=$(echo "$RESULT" | jq '.attrHead' | sed 's/\"//g')
    N_COMPLETIONS=$(echo "$COMPLETIONS" | wc -w)
    if [ $N_COMPLETIONS = 0 ]; then
	return
    elif [ $N_COMPLETIONS = 1 ]; then
	TO_ADD=$(echo $COMPLETIONS | sed s/$ATTR_HEAD//)
	READLINE_LINE+="$TO_ADD"
	(( READLINE_POINT += $(echo "$TO_ADD" | wc -c) ))
    else
	echo "$COMPLETIONS" | columns
    fi
}

main_loop() {
    if [ -t 1 ] && [ $MODE = simple ]; then
	bind -x '"\t"':autocomplete 2> /dev/null
    fi
    while true; do
        ask_user_for_input
        eval_javascript_in_looking_glass "$input_buffer"
    done
}

check_for_unsafe_mode

if [ "$1" = "--notui" ]; then
    export MODE=simple
else
    export MODE=tui
fi

trap 'quit_message' SIGINT

if [ $MODE = tui ]; then
    init_terminal
    load_history
fi

main_loop

if [ $MODE = tui ]; then
    restore_terminal
fi
